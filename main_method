/*
 * File: Breakout.java
 * -------------------
 * Name: Anastasiia Syzonenko, Samorodova Sofiia
 * Section Leader: 
 * 
 * This file will eventually implement the game of Breakout.
 */

import acm.graphics.*;
import acm.program.*;
import acm.util.*;

import java.applet.*;
import java.awt.*;
import java.awt.event.*;

public class Breakout extends GraphicsProgram {

/** Width and height of application window in pixels */
	public static final int APPLICATION_WIDTH = 400;
	public static final int APPLICATION_HEIGHT = 600;

/** Dimensions of game board (usually the same) */
	private static final int WIDTH = APPLICATION_WIDTH;
	private static final int HEIGHT = APPLICATION_HEIGHT;

/** Dimensions of the paddle */
	private static final int PADDLE_WIDTH = 60;
	private static final int PADDLE_HEIGHT = 10;

/** Offset of the paddle up from the bottom */
	private static final int PADDLE_Y_OFFSET = 30;

/** Number of bricks per row */
	private static final int NBRICKS_PER_ROW = 10;

/** Number of rows of bricks */
	private static final int NBRICK_ROWS = 10;

/** Separation between bricks */
	private static final int BRICK_SEP = 4;

/** Width of a brick */
	private static final int BRICK_WIDTH =
	  (WIDTH - (NBRICKS_PER_ROW - 1) * BRICK_SEP) / NBRICKS_PER_ROW;

/** Height of a brick */
	private static final int BRICK_HEIGHT = 8;

/** Radius of the ball in pixels */
	private static final int BALL_RADIUS = 10;

/** Offset of the top brick row from the top */
	private static final int BRICK_Y_OFFSET = 70;

/** Number of turns */
	private static final int NTURNS = 3;

/* Method: run() */
/** Runs the Breakout program. */
// just code

public void run() {
         	/* You fill this in, along with any subsidiary methods */
         	setup();
 
  	}
/**
 * Setup bricks and a paddle. Add mouse listeners
 */
  	private void setup() {
         	this.setSize(APPLICATION_WIDTH, APPLICATION_HEIGHT);
         	
         	for(int i = 0; i<NBRICK_ROWS; i++) {
               	for(int j = 0; j<NBRICKS_PER_ROW; j++) {
                      	int x = j*(BRICK_WIDTH + BRICK_SEP);
                      	int y = i*(BRICK_HEIGHT + BRICK_SEP) + BRICK_Y_OFFSET;
         	brick = new GRect(BRICK_WIDTH, BRICK_HEIGHT); //Our brick
         	brick.setFilled(true);
         	if(i==0||i==1)
               	brick.setColor(Color.RED);
         	else if(i==2||i==3)
               	brick.setColor(Color.ORANGE);
         	else if(i==4||i==5)
               	brick.setColor(Color.YELLOW);
         	else if(i==6||i==7)
               	brick.setColor(Color.GREEN);
         	else
               	brick.setColor(Color.CYAN);
         	add(brick,x,y);
               	}
         	}
         	
         	paddle = new GRect(PADDLE_WIDTH, PADDLE_HEIGHT); //Our paddle
         	paddle.setFilled(true);
         	add(paddle, (WIDTH-PADDLE_WIDTH)/2, HEIGHT-PADDLE_HEIGHT-PADDLE_Y_OFFSET);
		
		ball = new GOval(BALL_RADIUS, BALL_RADIUS);
		ball.setColor(Color.MAGENTA);
		ball.setFilled(true);
		ball.setFillColor(Color.MAGENTA);
		add(ball, (APPLICATION_WIDTH - BALL_RADIUS)/2, (APPLICATION_HEIGHT - BALL_RADIUS)/2);
         	
         	addMouseListeners();
  	}
  	
         	
  	public void mousePressed(MouseEvent e) {
         	last = new GPoint(e.getPoint());
         	gobj = getElementAt(last);
  	}
  	
  	public void mouseDragged(MouseEvent e) {
         	if(gobj==paddle) {
               	if(paddle.getX()>0&&paddle.getX()<WIDTH-PADDLE_WIDTH) {
               	gobj.move(e.getX() - last.getX(), 0);
               	last = new GPoint(e.getPoint());
               	}
               	else if(e.getX()<=PADDLE_WIDTH){
                      	gobj.setLocation(0, HEIGHT-PADDLE_HEIGHT-PADDLE_Y_OFFSET);
                      	gobj.move(1, 0);
               	}
               	else {
                      	gobj.setLocation(WIDTH-PADDLE_WIDTH-2, HEIGHT-PADDLE_HEIGHT-PADDLE_Y_OFFSET);
                      	gobj.move(-1, 0);
               	}
         	}
  	}
  	private GRect brick;
  	private GRect paddle;
  	private GPoint last;
  	private GObject gobj;
 
}
 

